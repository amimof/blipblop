// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/services/containers/v1/containers.proto

package containers

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	events "github.com/amimof/blipblop/api/services/events/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = events.EventType(0)
)

// Validate checks the field values on Container with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Container) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Container with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerMultiError, or nil
// if none found.
func (m *Container) ValidateAll() error {
	return m.validate(true)
}

func (m *Container) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMeta() == nil {
		err := ContainerValidationError{
			field:  "Meta",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetConfig() == nil {
		err := ContainerValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContainerValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContainerValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ContainerMultiError(errors)
	}

	return nil
}

// ContainerMultiError is an error wrapping multiple validation errors returned
// by Container.ValidateAll() if the designated constraints aren't met.
type ContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerMultiError) AllErrors() []error { return m }

// ContainerValidationError is the validation error returned by
// Container.Validate if the designated constraints aren't met.
type ContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerValidationError) ErrorName() string { return "ContainerValidationError" }

// Error satisfies the builtin error interface
func (e ContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerValidationError{}

// Validate checks the field values on Status with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Status) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Status with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StatusMultiError, or nil if none found.
func (m *Status) ValidateAll() error {
	return m.validate(true)
}

func (m *Status) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phase

	// no validation rules for Node

	// no validation rules for Ip

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRuntime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StatusValidationError{
					field:  "Runtime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRuntime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StatusValidationError{
				field:  "Runtime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StatusMultiError(errors)
	}

	return nil
}

// StatusMultiError is an error wrapping multiple validation errors returned by
// Status.ValidateAll() if the designated constraints aren't met.
type StatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusMultiError) AllErrors() []error { return m }

// StatusValidationError is the validation error returned by Status.Validate if
// the designated constraints aren't met.
type StatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusValidationError) ErrorName() string { return "StatusValidationError" }

// Error satisfies the builtin error interface
func (e StatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusValidationError{}

// Validate checks the field values on TaskStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskStatusMultiError, or
// nil if none found.
func (m *TaskStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pid

	// no validation rules for ExitStatus

	if all {
		switch v := interface{}(m.GetExitTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskStatusValidationError{
					field:  "ExitTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskStatusValidationError{
					field:  "ExitTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExitTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskStatusValidationError{
				field:  "ExitTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if len(errors) > 0 {
		return TaskStatusMultiError(errors)
	}

	return nil
}

// TaskStatusMultiError is an error wrapping multiple validation errors
// returned by TaskStatus.ValidateAll() if the designated constraints aren't met.
type TaskStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskStatusMultiError) AllErrors() []error { return m }

// TaskStatusValidationError is the validation error returned by
// TaskStatus.Validate if the designated constraints aren't met.
type TaskStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskStatusValidationError) ErrorName() string { return "TaskStatusValidationError" }

// Error satisfies the builtin error interface
func (e TaskStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskStatusValidationError{}

// Validate checks the field values on RuntimeStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeStatusMultiError, or
// nil if none found.
func (m *RuntimeStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeEnv

	// no validation rules for RuntimeVersion

	// no validation rules for StdoutPath

	// no validation rules for StderrPath

	if len(errors) > 0 {
		return RuntimeStatusMultiError(errors)
	}

	return nil
}

// RuntimeStatusMultiError is an error wrapping multiple validation errors
// returned by RuntimeStatus.ValidateAll() if the designated constraints
// aren't met.
type RuntimeStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeStatusMultiError) AllErrors() []error { return m }

// RuntimeStatusValidationError is the validation error returned by
// RuntimeStatus.Validate if the designated constraints aren't met.
type RuntimeStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeStatusValidationError) ErrorName() string { return "RuntimeStatusValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeStatusValidationError{}

// Validate checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Config) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ConfigMultiError, or nil if none found.
func (m *Config) ValidateAll() error {
	return m.validate(true)
}

func (m *Config) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetImage()) < 1 {
		err := ConfigValidationError{
			field:  "Image",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("Mounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("Mounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigValidationError{
					field:  fmt.Sprintf("Mounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPortMappings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("PortMappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("PortMappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigValidationError{
					field:  fmt.Sprintf("PortMappings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NodeSelector

	if len(errors) > 0 {
		return ConfigMultiError(errors)
	}

	return nil
}

// ConfigMultiError is an error wrapping multiple validation errors returned by
// Config.ValidateAll() if the designated constraints aren't met.
type ConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMultiError) AllErrors() []error { return m }

// ConfigValidationError is the validation error returned by Config.Validate if
// the designated constraints aren't met.
type ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigValidationError) ErrorName() string { return "ConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigValidationError{}

// Validate checks the field values on Mount with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Mount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mount with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MountMultiError, or nil if none found.
func (m *Mount) ValidateAll() error {
	return m.validate(true)
}

func (m *Mount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Destination

	// no validation rules for Type

	// no validation rules for Source

	if len(errors) > 0 {
		return MountMultiError(errors)
	}

	return nil
}

// MountMultiError is an error wrapping multiple validation errors returned by
// Mount.ValidateAll() if the designated constraints aren't met.
type MountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MountMultiError) AllErrors() []error { return m }

// MountValidationError is the validation error returned by Mount.Validate if
// the designated constraints aren't met.
type MountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MountValidationError) ErrorName() string { return "MountValidationError" }

// Error satisfies the builtin error interface
func (e MountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MountValidationError{}

// Validate checks the field values on PortMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PortMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PortMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PortMappingMultiError, or
// nil if none found.
func (m *PortMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *PortMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostPort

	// no validation rules for ContainerPort

	// no validation rules for Protocol

	// no validation rules for HostIP

	if len(errors) > 0 {
		return PortMappingMultiError(errors)
	}

	return nil
}

// PortMappingMultiError is an error wrapping multiple validation errors
// returned by PortMapping.ValidateAll() if the designated constraints aren't met.
type PortMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PortMappingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PortMappingMultiError) AllErrors() []error { return m }

// PortMappingValidationError is the validation error returned by
// PortMapping.Validate if the designated constraints aren't met.
type PortMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PortMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PortMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PortMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PortMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PortMappingValidationError) ErrorName() string { return "PortMappingValidationError" }

// Error satisfies the builtin error interface
func (e PortMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPortMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PortMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PortMappingValidationError{}

// Validate checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Event) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EventMultiError, or nil if none found.
func (m *Event) ValidateAll() error {
	return m.validate(true)
}

func (m *Event) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for Description

	if len(errors) > 0 {
		return EventMultiError(errors)
	}

	return nil
}

// EventMultiError is an error wrapping multiple validation errors returned by
// Event.ValidateAll() if the designated constraints aren't met.
type EventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventMultiError) AllErrors() []error { return m }

// EventValidationError is the validation error returned by Event.Validate if
// the designated constraints aren't met.
type EventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventValidationError) ErrorName() string { return "EventValidationError" }

// Error satisfies the builtin error interface
func (e EventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventValidationError{}

// Validate checks the field values on GetContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetContainerRequestMultiError, or nil if none found.
func (m *GetContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetContainerRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetContainerRequestMultiError(errors)
	}

	return nil
}

// GetContainerRequestMultiError is an error wrapping multiple validation
// errors returned by GetContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type GetContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContainerRequestMultiError) AllErrors() []error { return m }

// GetContainerRequestValidationError is the validation error returned by
// GetContainerRequest.Validate if the designated constraints aren't met.
type GetContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContainerRequestValidationError) ErrorName() string {
	return "GetContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContainerRequestValidationError{}

// Validate checks the field values on GetContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetContainerResponseMultiError, or nil if none found.
func (m *GetContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContainer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetContainerResponseValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetContainerResponseValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetContainerResponseValidationError{
				field:  "Container",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetContainerResponseMultiError(errors)
	}

	return nil
}

// GetContainerResponseMultiError is an error wrapping multiple validation
// errors returned by GetContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type GetContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContainerResponseMultiError) AllErrors() []error { return m }

// GetContainerResponseValidationError is the validation error returned by
// GetContainerResponse.Validate if the designated constraints aren't met.
type GetContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContainerResponseValidationError) ErrorName() string {
	return "GetContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContainerResponseValidationError{}

// Validate checks the field values on CreateContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateContainerRequestMultiError, or nil if none found.
func (m *CreateContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetContainer() == nil {
		err := CreateContainerRequestValidationError{
			field:  "Container",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetContainer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateContainerRequestValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateContainerRequestValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateContainerRequestValidationError{
				field:  "Container",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateContainerRequestMultiError(errors)
	}

	return nil
}

// CreateContainerRequestMultiError is an error wrapping multiple validation
// errors returned by CreateContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateContainerRequestMultiError) AllErrors() []error { return m }

// CreateContainerRequestValidationError is the validation error returned by
// CreateContainerRequest.Validate if the designated constraints aren't met.
type CreateContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateContainerRequestValidationError) ErrorName() string {
	return "CreateContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateContainerRequestValidationError{}

// Validate checks the field values on CreateContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateContainerResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateContainerResponseMultiError, or nil if none found.
func (m *CreateContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContainer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateContainerResponseValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateContainerResponseValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateContainerResponseValidationError{
				field:  "Container",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateContainerResponseMultiError(errors)
	}

	return nil
}

// CreateContainerResponseMultiError is an error wrapping multiple validation
// errors returned by CreateContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateContainerResponseMultiError) AllErrors() []error { return m }

// CreateContainerResponseValidationError is the validation error returned by
// CreateContainerResponse.Validate if the designated constraints aren't met.
type CreateContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateContainerResponseValidationError) ErrorName() string {
	return "CreateContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateContainerResponseValidationError{}

// Validate checks the field values on UpdateContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateContainerRequestMultiError, or nil if none found.
func (m *UpdateContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateContainerRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetContainer() == nil {
		err := UpdateContainerRequestValidationError{
			field:  "Container",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetContainer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateContainerRequestValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateContainerRequestValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateContainerRequestValidationError{
				field:  "Container",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateContainerRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateContainerRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateContainerRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateContainerRequestMultiError(errors)
	}

	return nil
}

// UpdateContainerRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateContainerRequestMultiError) AllErrors() []error { return m }

// UpdateContainerRequestValidationError is the validation error returned by
// UpdateContainerRequest.Validate if the designated constraints aren't met.
type UpdateContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateContainerRequestValidationError) ErrorName() string {
	return "UpdateContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateContainerRequestValidationError{}

// Validate checks the field values on UpdateContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateContainerResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateContainerResponseMultiError, or nil if none found.
func (m *UpdateContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContainer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateContainerResponseValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateContainerResponseValidationError{
					field:  "Container",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateContainerResponseValidationError{
				field:  "Container",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateContainerResponseMultiError(errors)
	}

	return nil
}

// UpdateContainerResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateContainerResponseMultiError) AllErrors() []error { return m }

// UpdateContainerResponseValidationError is the validation error returned by
// UpdateContainerResponse.Validate if the designated constraints aren't met.
type UpdateContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateContainerResponseValidationError) ErrorName() string {
	return "UpdateContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateContainerResponseValidationError{}

// Validate checks the field values on DeleteContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteContainerRequestMultiError, or nil if none found.
func (m *DeleteContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := DeleteContainerRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteContainerRequestMultiError(errors)
	}

	return nil
}

// DeleteContainerRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteContainerRequestMultiError) AllErrors() []error { return m }

// DeleteContainerRequestValidationError is the validation error returned by
// DeleteContainerRequest.Validate if the designated constraints aren't met.
type DeleteContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteContainerRequestValidationError) ErrorName() string {
	return "DeleteContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteContainerRequestValidationError{}

// Validate checks the field values on DeleteContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteContainerResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteContainerResponseMultiError, or nil if none found.
func (m *DeleteContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteContainerResponseMultiError(errors)
	}

	return nil
}

// DeleteContainerResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteContainerResponseMultiError) AllErrors() []error { return m }

// DeleteContainerResponseValidationError is the validation error returned by
// DeleteContainerResponse.Validate if the designated constraints aren't met.
type DeleteContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteContainerResponseValidationError) ErrorName() string {
	return "DeleteContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteContainerResponseValidationError{}

// Validate checks the field values on ListContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListContainerRequestMultiError, or nil if none found.
func (m *ListContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Selector

	if len(errors) > 0 {
		return ListContainerRequestMultiError(errors)
	}

	return nil
}

// ListContainerRequestMultiError is an error wrapping multiple validation
// errors returned by ListContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type ListContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListContainerRequestMultiError) AllErrors() []error { return m }

// ListContainerRequestValidationError is the validation error returned by
// ListContainerRequest.Validate if the designated constraints aren't met.
type ListContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListContainerRequestValidationError) ErrorName() string {
	return "ListContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListContainerRequestValidationError{}

// Validate checks the field values on ListContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListContainerResponseMultiError, or nil if none found.
func (m *ListContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetContainers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListContainerResponseValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListContainerResponseValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListContainerResponseValidationError{
					field:  fmt.Sprintf("Containers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListContainerResponseMultiError(errors)
	}

	return nil
}

// ListContainerResponseMultiError is an error wrapping multiple validation
// errors returned by ListContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type ListContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListContainerResponseMultiError) AllErrors() []error { return m }

// ListContainerResponseValidationError is the validation error returned by
// ListContainerResponse.Validate if the designated constraints aren't met.
type ListContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListContainerResponseValidationError) ErrorName() string {
	return "ListContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListContainerResponseValidationError{}

// Validate checks the field values on StartContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartContainerRequestMultiError, or nil if none found.
func (m *StartContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := StartContainerRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StartContainerRequestMultiError(errors)
	}

	return nil
}

// StartContainerRequestMultiError is an error wrapping multiple validation
// errors returned by StartContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type StartContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartContainerRequestMultiError) AllErrors() []error { return m }

// StartContainerRequestValidationError is the validation error returned by
// StartContainerRequest.Validate if the designated constraints aren't met.
type StartContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartContainerRequestValidationError) ErrorName() string {
	return "StartContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartContainerRequestValidationError{}

// Validate checks the field values on StartContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartContainerResponseMultiError, or nil if none found.
func (m *StartContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return StartContainerResponseMultiError(errors)
	}

	return nil
}

// StartContainerResponseMultiError is an error wrapping multiple validation
// errors returned by StartContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type StartContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartContainerResponseMultiError) AllErrors() []error { return m }

// StartContainerResponseValidationError is the validation error returned by
// StartContainerResponse.Validate if the designated constraints aren't met.
type StartContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartContainerResponseValidationError) ErrorName() string {
	return "StartContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartContainerResponseValidationError{}

// Validate checks the field values on StopContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopContainerRequestMultiError, or nil if none found.
func (m *StopContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StopContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := StopContainerRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StopContainerRequestMultiError(errors)
	}

	return nil
}

// StopContainerRequestMultiError is an error wrapping multiple validation
// errors returned by StopContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type StopContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopContainerRequestMultiError) AllErrors() []error { return m }

// StopContainerRequestValidationError is the validation error returned by
// StopContainerRequest.Validate if the designated constraints aren't met.
type StopContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopContainerRequestValidationError) ErrorName() string {
	return "StopContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StopContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopContainerRequestValidationError{}

// Validate checks the field values on StopContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopContainerResponseMultiError, or nil if none found.
func (m *StopContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StopContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return StopContainerResponseMultiError(errors)
	}

	return nil
}

// StopContainerResponseMultiError is an error wrapping multiple validation
// errors returned by StopContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type StopContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopContainerResponseMultiError) AllErrors() []error { return m }

// StopContainerResponseValidationError is the validation error returned by
// StopContainerResponse.Validate if the designated constraints aren't met.
type StopContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopContainerResponseValidationError) ErrorName() string {
	return "StopContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StopContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopContainerResponseValidationError{}

// Validate checks the field values on KillContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KillContainerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KillContainerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KillContainerRequestMultiError, or nil if none found.
func (m *KillContainerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *KillContainerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := KillContainerRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ForceKill

	if len(errors) > 0 {
		return KillContainerRequestMultiError(errors)
	}

	return nil
}

// KillContainerRequestMultiError is an error wrapping multiple validation
// errors returned by KillContainerRequest.ValidateAll() if the designated
// constraints aren't met.
type KillContainerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KillContainerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KillContainerRequestMultiError) AllErrors() []error { return m }

// KillContainerRequestValidationError is the validation error returned by
// KillContainerRequest.Validate if the designated constraints aren't met.
type KillContainerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KillContainerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KillContainerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KillContainerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KillContainerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KillContainerRequestValidationError) ErrorName() string {
	return "KillContainerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e KillContainerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKillContainerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KillContainerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KillContainerRequestValidationError{}

// Validate checks the field values on KillContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KillContainerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KillContainerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KillContainerResponseMultiError, or nil if none found.
func (m *KillContainerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *KillContainerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return KillContainerResponseMultiError(errors)
	}

	return nil
}

// KillContainerResponseMultiError is an error wrapping multiple validation
// errors returned by KillContainerResponse.ValidateAll() if the designated
// constraints aren't met.
type KillContainerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KillContainerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KillContainerResponseMultiError) AllErrors() []error { return m }

// KillContainerResponseValidationError is the validation error returned by
// KillContainerResponse.Validate if the designated constraints aren't met.
type KillContainerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KillContainerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KillContainerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KillContainerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KillContainerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KillContainerResponseValidationError) ErrorName() string {
	return "KillContainerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e KillContainerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKillContainerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KillContainerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KillContainerResponseValidationError{}
